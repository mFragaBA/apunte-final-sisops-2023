<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Entrada/Salida - Notas Final Sistemas Operativos 2023</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="././mdbook-admonish.css">
        <link rel="stylesheet" href="./custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduccion.html"><strong aria-hidden="true">1.</strong> Introducci√≥n</a></li><li class="chapter-item expanded "><a href="procesos_y_api.html"><strong aria-hidden="true">2.</strong> Procesos y API del SO</a></li><li class="chapter-item expanded "><a href="ipc.html"><strong aria-hidden="true">3.</strong> Intercomunicaci√≥n Entre Procesos</a></li><li class="chapter-item expanded "><a href="scheduling.html"><strong aria-hidden="true">4.</strong> Scheduling</a></li><li class="chapter-item expanded "><a href="sincro_entre_procesos.html"><strong aria-hidden="true">5.</strong> Sincronizaci√≥n entre procesos</a></li><li class="chapter-item expanded "><a href="sincronizacion.html"><strong aria-hidden="true">6.</strong> Sincronizaci√≥n</a></li><li class="chapter-item expanded "><a href="administracion_de_memoria.html"><strong aria-hidden="true">7.</strong> Administraci√≥n de Memoria</a></li><li class="chapter-item expanded "><a href="entrada_salida.html" class="active"><strong aria-hidden="true">8.</strong> Entrada/Salida</a></li><li class="chapter-item expanded "><a href="sistemas_de_archivos.html"><strong aria-hidden="true">9.</strong> Sistemas de Archivos</a></li><li class="chapter-item expanded "><a href="sistemas_distribuidos.html"><strong aria-hidden="true">10.</strong> Sistemas Distribuidos</a></li><li class="chapter-item expanded "><a href="sistemas_distribuidos_II.html"><strong aria-hidden="true">11.</strong> Sistemas Distribuidos - parte II</a></li><li class="chapter-item expanded "><a href="proteccion_y_seguridad.html"><strong aria-hidden="true">12.</strong> Protecci√≥n y Seguridad</a></li><li class="chapter-item expanded "><a href="virtualizacion.html"><strong aria-hidden="true">13.</strong> Virtualizaci√≥n</a></li><li class="chapter-item expanded "><a href="microkernels.html"><strong aria-hidden="true">14.</strong> Microkernels</a></li><li class="chapter-item expanded "><a href="misc.html"><strong aria-hidden="true">15.</strong> Miscelaneos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="memory_allocator_bsd.html"><strong aria-hidden="true">15.1.</strong> Design of a General Purpose Memory Allocator for the 4.3BSD UNIX Kernel</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Notas Final Sistemas Operativos 2023</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="entradasalida"><a class="header" href="#entradasalida">Entrada/Salida</a></h1>
<p>Nos vamos a concentrar en dispositivos de almacenamiento. Dentro de estos se incluyen:</p>
<ul>
<li>Discos R√≠gidos (hoy tambi√©n discos s√≥lidos).</li>
<li>Unidades de cinta: principalmente usados para backup</li>
<li>Discos removibles: cd, dvd, disquette, usb, etc.</li>
<li>discos virtuales (tambi√©n llamados NAS: Network Attached Storage): NFS, CIFS,
DFS, AFS, Coda</li>
<li>Storage Area Network (SAN): similar a Nas, tengo el almacenamiento en red pero los protocolos que usa son espec√≠ficos para este tipo de datos.</li>
</ul>
<h2 id="subsistema-de-io-y-modelo"><a class="header" href="#subsistema-de-io-y-modelo">Subsistema de I/O y Modelo</a></h2>
<p>Conceptualmente un dispositivo de I/O consta de dos partes:</p>
<ul>
<li>El dispositivo f√≠sico</li>
<li>Un <strong>controlador del dispositivo</strong> (ojo, no son los drivers de software si no
de hw) que interact√∫a con el SO mediante alg√∫n bus o registro.</li>
</ul>
<p>Al igual que con otros subsistemas, el sistema operativo mediante <strong>drivers</strong> logra abstraer detalles propios del dispositivo al usuario:</p>
<p><img src="./img/io_subsystem.png#floating" alt="layout subsistema I/O" /></p>
<ul>
<li>Los drivers conocen las particularidades del HW con el que se comunican.</li>
<li>Por lo general los drivers son provistos por el mismo fabricante de HW que el
dispositivo.</li>
<li>Distintos modelos de un mismo fabricante pueden usar distintos drivers.</li>
<li>Por ejemplo, algo a considerar por un driver puede ser qu√© bit hay que leer
para marcar el final de una operaci√≥n.</li>
<li>Tienen un impacto muy grande sobre el rendimiento del sistema:
<ul>
<li>corren en m√°ximo privilegio (a.k.a te pueden hacer bosta todo el sistema)</li>
<li>De ellos depende el rendimiento del I/O que como vimos es frecuentemente
usado y fundamental para el rendimiento general del sistema.</li>
</ul>
</li>
</ul>
<h2 id="formas-de-io"><a class="header" href="#formas-de-io">Formas de I/O</a></h2>
<p>Vemos 3 formas de implementar I/O (por lo general en la pr√°ctica est√°n disponibles las 3):</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Polling</th><th>Interrupciones (o push)</th><th>DMA (acceso directo a memoria)</th></tr></thead><tbody>
<tr><td>üìÑ Desc.</td><td>El driver peri√≥dicamente verifica si el dispositivo se comunic√≥</td><td>El dispositivo avisa mediante interrupciones</td><td>La CPU no interviene (por lo general para transferir grandes vol√∫menes de info)</td></tr>
<tr><td>‚úÖ Ventajas</td><td>Cambios de contexto predecibles</td><td>Eventos asincr√≥nicos poco frecuentes</td><td>Cuando el controlador de DMA finaliza, interrupe a la CPU (1 vs varios para comunicarse en interrupciones)</td></tr>
<tr><td>üíÄ Desventajas</td><td>Alto consumo de CPU</td><td>Cambios de contexto impredecibles</td><td>Necesit√°s el componente espec√≠fico de HW (controlador de DMA)</td></tr>
</tbody></table>
</div>
<h2 id="api-de-io"><a class="header" href="#api-de-io">API de I/O</a></h2>
<p>Tenemos las syscalls:</p>
<ul>
<li><code>open()</code>/ <code>close()</code></li>
<li><code>read()</code> / <code>write()</code></li>
<li><code>seek()</code></li>
</ul>
<p>Ocultan bastante de la complejidad, aunque hay algunos detalles que se exponen (ej: si se obtiene acceso exclusivo al dispositivo o no)</p>
<h2 id="tipos-de-dispositivos"><a class="header" href="#tipos-de-dispositivos">Tipos de dispositivos</a></h2>
<p>Los dispositivos pueden separarse en 2 grupos:</p>
<ul>
<li><strong>char device</strong>: 
<ul>
<li>la info se transmite byte a byte, debido a eso no tienen acceso aleatorio y utilizan caches para mejorar la performance.</li>
<li>ej: mouse, teclado, terminales, puerto serie.</li>
</ul>
</li>
<li><strong>block device</strong>:
<ul>
<li>se transmite info en bloque, permite acceso aleatorio y en general usan un buffer.</li>
<li>ej: disco r√≠gido, memoria flash, cd rom</li>
</ul>
</li>
</ul>
<p>Si bien esta es una clasificaci√≥n general, la comunicaci√≥n con dispositivos tiene otras variables:</p>
<ul>
<li>Si es lectura, escritura o lecto-escritura</li>
<li>Si es compartido o dedicado</li>
<li>Si es sincr√≥nico o asincr√≥nico</li>
<li>La velocidad de respuesta del dispositivo</li>
</ul>
<p>Parte del objetivo del SO y la api de I/O es ocultar la mayor cantidad de
detalles posibles y a la vez brindar acceso consistente a toda la fauna de
dispositivos.</p>
<details id="admonition-dispositivos-en-linux" class="admonition info">
<summary class="admonition-title">
<p>Dispositivos en Linux</p>
<p><a class="admonition-anchor-link" href="#admonition-dispositivos-en-linux"></a></p>
</summary>
<div>
<p>Los dispoistivos en linux est√°n representados por archivos y se ubican en el directorio <code>/dev</code>. En el siguiente ejemplo, podemos ver que el archivo contiene informaci√≥n del tipo de archivo (c para char device, b para block device):</p>
<pre><code class="language-bash">ls -lh /dev
crw-rw-rw-  1 root    wheel        0x9000001 Mar  5 12:06 cu.wlan-debug
brw-r-----  1 root    operator     0x1000000 Mar  5 12:06 disk0
brw-r-----  1 root    operator     0x1000001 Mar  5 12:06 disk0s1
brw-r-----  1 root    operator     0x1000002 Mar  5 12:06 disk0s2
brw-r-----  1 root    operator     0x1000003 Mar  5 12:06 disk0s3
</code></pre>
</div>
</details>
<div id="admonition-api-de-io-en-linux" class="admonition info">
<div class="admonition-title">
<p>API de I/O en linux</p>
<p><a class="admonition-anchor-link" href="#admonition-api-de-io-en-linux"></a></p>
</div>
<div>
<p>En el caso de linux, bajo la premisa de que <em>&quot;todo es un archivo&quot;</em> se proveen funciones de alto nivel para acceso a archivos:</p>
<ul>
<li><code>fopen()</code>, <code>fclose()</code></li>
<li><code>fread()</code>, <code>fwrite()</code>: modo bloque</li>
<li><code>fgetc()</code>, <code>fputc()</code>: modo char</li>
<li><code>fgets()</code>, <code>fputs()</code>: modo char stream (ej: con esto puedo escribir en consola)</li>
<li><code>fscanf()</code>, <code>fprintf()</code>: modo char con formato</li>
</ul>
</div>
</div>
<h2 id="planificaci√≥n-de-io"><a class="header" href="#planificaci√≥n-de-io">Planificaci√≥n de I/O</a></h2>
<p>En el caso del disco, una de las claves para obtener un buen rendimiento es
optimizar los accesos al mismo. Esto es porque el disco consiste de una cabeza
que se mueve, y eso lleva tiempo. Si junto varios pedidos y los ordeno de
manera tal que minimice la cantidad de movimientos voy a mejorar mucho la
performance.</p>
<p>La planificaci√≥n de disco entronces se trata de c√≥mo manejar la cola de pedidos
de I/O para lograr el mejor rendimiento posible. Es un equilibrio entre ancho
de banda, latencia rotacional y <strong>tiempo de b√∫squeda (seek time)</strong>, que es el
tiempo necesario para que la cabeza se ubique sobre el cilindro que tiene el
sector deseado.</p>
<h3 id="pol√≠ticas-de-scheduling-de-io-a-disco"><a class="header" href="#pol√≠ticas-de-scheduling-de-io-a-disco">Pol√≠ticas de scheduling de I/O a disco</a></h3>
<p>Tenemos algunos esquemas:</p>
<ul>
<li>FIFO
<ul>
<li>problema: estoy moviendo la cabeza de un lado a otro, a menos que los
pedidos &quot;se porten bien&quot;.</li>
</ul>
</li>
<li>Shortest Seek Time First (SSTF)
<ul>
<li>idea: atiendo como pr√≥ximo al pedido m√°s cercano a la posici√≥n actual de la
cabeza (o sea es un algoritmo goloso)</li>
<li>si bien mejora el tiempo de respuesta, puede producit inanici√≥n</li>
</ul>
</li>
<li><strong>Algoritmo scan o del ascensor</strong>
<ul>
<li>idea: ir primero en un sentido, atendiendo los pedidos en el camino. Luego
vuelvo y hago lo mismo.</li>
<li>es una mejora, aunque si me piden un sector por donde acaba de pasar la
cabeza tardo muuuuucho.</li>
<li>adem√°s no es tan uniforme (predecible) el tiempo de espera</li>
</ul>
</li>
<li><strong>C-Scan</strong>: igual a scan pero al llegar al final vuelve al principio sin
atender otros pedidos (asume que el disco es una lista circular)</li>
</ul>
<div id="admonition-nota" class="admonition info">
<div class="admonition-title">
<p>Nota</p>
<p><a class="admonition-anchor-link" href="#admonition-nota"></a></p>
</div>
<div>
<p>En la pr√°ctica ninguno de estos algoritmos se usan al 100%, suele ser una mezcla entre estos, prioridades, caches, etc.</p>
</div>
</div>
<h2 id="ssd"><a class="header" href="#ssd">SSD</a></h2>
<p>Hoy en d√≠a prolifera el uso de discos de estado s√≥lido (SSD). Si bien tienen notables ventajas (m√°s resistentes, menor consumo, m√°s silenciosos, mejor performance de lectura), tambi√©n presenta sus propios problemas:</p>
<ul>
<li>durabilidad</li>
<li>write amplification</li>
</ul>
<!-- TODO: expandir esto -->
<h2 id="gesti√≥n-del-disco"><a class="header" href="#gesti√≥n-del-disco">Gesti√≥n del disco</a></h2>
<h3 id="formateo"><a class="header" href="#formateo">Formateo</a></h3>
<p>Consiste en poner por cada sector c√≥digos para detecci√≥n de errores,
puntualmente un prefijo y un postfijo. Si al leer un sector, el prefijo y
postfijo no tienen el valor esperado es porque el sector est√° da√±ado.</p>
<h3 id="booteo"><a class="header" href="#booteo">Booteo</a></h3>
<p>Las computadoras suelen tener un programa en ROM que carga algunos sectores del
principio del disco, y los comienza a ejecutar (bootloader?). Dicho programa es
muy peque√±o y solamente sirve para cargar el OS, no es un OS en s√≠ mismo.</p>
<h3 id="manejo-de-bloques-da√±ados"><a class="header" href="#manejo-de-bloques-da√±ados">Manejo de bloques da√±ados</a></h3>
<p>Hay distintas formas de atajarnos:</p>
<ul>
<li>por software, si hacemos que el sistema de archivos se encarge de la gesti√≥n
de bloques da√±ados</li>
<li>por hardware:
<ul>
<li>hay discos que vienen con sectores extra para reemplazar a los defectuosos.
A veces algunos discos traen sectores extra en todos los cilindros</li>
<li>cuando la controladora detecta un bloque da√±ado puede actualizar una tabla
interna de remapeo para usar un sector distinto (esto puede interferir con
las optimizaciones del scheduler de I/O)</li>
</ul>
</li>
</ul>
<h2 id="spooling-simultaneous-peripheral-operation-on-line"><a class="header" href="#spooling-simultaneous-peripheral-operation-on-line">Spooling (Simultaneous Peripheral Operation On-Line)</a></h2>
<p>Spooling permite interactuar con dispositivos que requieren acceso dedicado sin
bloquear al proceso que los necesita. El ejemplo m√°s distintivo es el de la
impresora. Cuando uno imprime, en lugar de bloquearse el proceso hasta tener
acceso, se encola el trabajo en una cola espec√≠fica y se tiene un proceso que
se encarga de desencolarla a medida que la impresora (o el dispositivo en otros
casos) se libera.</p>
<div id="admonition-nota-1" class="admonition info">
<div class="admonition-title">
<p>Nota</p>
<p><a class="admonition-anchor-link" href="#admonition-nota-1"></a></p>
</div>
<div>
<p>En el caso de spooling, el usuario es consciente de que ocurre pero el kernel no.</p>
</div>
</div>
<h2 id="protecci√≥n-de-la-informaci√≥n"><a class="header" href="#protecci√≥n-de-la-informaci√≥n">Protecci√≥n de la informaci√≥n</a></h2>
<p>Vamos a ver algunas t√©cnicas que podemos emplear para proteger nuestros datos.
Muchas veces dependiendo del tipo de dato, del valor que le asignemos y el
costo de mantenerlo vamos a optar por una u otra manera. Con proteger nuestros
datos nos referimos a por ejemplo que el disco falle y se descomponga alg√∫n
sector (o el disco entero), a que tengo una aplicaci√≥n que est√° corriendo 24/7
y tengo que tener tolerancia a fallas, etc. Las dos t√©cnicas que vamos a ver son:</p>
<ul>
<li>copias de seguridad</li>
<li>redundancia</li>
</ul>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="#admonition-note"></a></p>
</div>
<div>
<p>En particular <strong>la redundancia no nos protege de la modificaci√≥n/eliminaci√≥n
accidental de la informaci√≥n</strong>. Es por eso que se suelen combinar ambas t√©cnicas.
Hay casos sin embargo en donde ninguna de las t√©cnicas nos salva (en alg√∫n
momento corrompemos datos/archivos y nos damos cuenta tarde con varios backups
encima). En esos casos los sistemas de archivos nos deber√≠an brindar algunas
protecciones para que eso no pase (o al menos no pase seguido).</p>
</div>
</div>
<h3 id="copias-de-seguridad"><a class="header" href="#copias-de-seguridad">Copias de seguridad</a></h3>
<p>Hacer una <strong>copia de seguridad (backup)</strong> consiste en resguardar los datos
(obviamente solo los importantes) en otro lado. Para grandes vol√∫menes de info,
se suele hacer en cinta o discos duros (Si es algo hogare√±o pod√©s hacerlo con
el dispositivo de almacenamiento externo que te plazca). De vuelta, en caso de
sistemas con mucha data, se suelen programar los backups para que se hagan de
noche.</p>
<p>Sin embargo, copiar <strong>todos</strong> los datos es muy caro. Por eso podemos implementar distintas estrategias:</p>
<ul>
<li>hacer una <strong>copia total</strong> con cierta frecuencia (cada semana, mes, bimestre, etc.)</li>
<li>hacer una <strong>copia incremental</strong> (por ejemplo cada noche): s√≥lo guarda los archivos modificados <strong>desde la √∫ltima copia incremental</strong></li>
<li>hacer una <strong>copia diferencial</strong>: s√≥lo guarda los archivos modificados desde la √∫ltima copia total (obviamente combino esto con hacer una copia total cada tanto).</li>
</ul>
<p>Cuando llega la hora de restaurar:</p>
<ul>
<li>si s√≥lo hago copias totales restauro la que quiero y listo</li>
</ul>
<p>\[
\text{Hoy} = \text{√∫ltimo total}
\]</p>
<ul>
<li>si hago copias diferenciales, agarro la √∫ltima copia total y aplico la √∫ltima
copia diferencial</li>
</ul>
<p>\[
\text{Hoy} = \text{√∫ltimo total} + \text{√∫ltimo diferencial}
\]</p>
<ul>
<li>si hago copias incrementales, agarro la √∫ltima copia total y aplico desde la
primera incremental despu√©s de la total hasta la √∫ltima (en ese orden)</li>
</ul>
<p>\[
\text{Hoy} = \text{√∫ltimo total} + \sum_i  \text{incremental}_i
\]</p>
<h3 id="redundancia"><a class="header" href="#redundancia">Redundancia</a></h3>
<p>El uso de redundancia es clave en sistemas que tienen que estar up 24/7, de
forma tal que las fallas en discos no te tiren el sistema (por supuesto, puede
caer un meteorito en cada datacenter del planeta y ah√≠ cagaste)</p>
<p>Un m√©todo muy usado es <strong>RAID</strong>: <strong>R</strong>edundant <strong>A</strong>rray of <strong>I</strong>nexpensive <strong>D</strong>isks. La t√©cnica fue evolucionando por lo que tenemos RAID en sus distintas versiones:</p>
<p>Podemos resumir en la siguiente tabla las distintas versiones (las m√°s usadas en la pr√°ctica) de RAID:</p>
<!-- TODO: armar tabla -->
<p><img src="./img/raid_0.png#floating" alt="" /></p>
<ul>
<li><strong>RAID 0 (stripping)</strong>
<ul>
<li>necesito 2 discos</li>
<li>Parto el archivo (o data) en pedacitos y mando algunos pedacitos a un disco y otros pedacitos a otro</li>
<li>en realidad no aporta redundancia, pero mejora el rendimiento (mejor ancho de banda y permito escrituras en paralelo)</li>
</ul>
</li>
</ul>
<!-- needed for images not to overlap -->
<p><br><br><br><br></p>
<p><img src="./img/raid_1.png#floating" alt="" /></p>
<ul>
<li><strong>RAID 1 (mirroring)</strong>
<ul>
<li>2 discos</li>
<li>espejo la data, si se cae un disco entero todav√≠a tengo la copia en el otro</li>
<li>mejora el rendimiento de las lecturas pero en peor caso tardo el doble en escribir (muy caro).</li>
</ul>
</li>
</ul>
<!-- needed for images not to overlap -->
<p><br><br><br><br><br></p>
<ul>
<li><strong>RAID 0+1</strong></li>
</ul>
<p><img src="./img/raid_0_plus_1.png#center" alt="" /></p>
<ul>
<li>
<ul>
<li>4 discos</li>
<li>combina los dos anteriores: cada archivo est√° espejado, pero al leer leo un bloque de cada disco.</li>
<li>leo como si usara stripping en lugar de s√≥lo mirroring, pero al escribir hay que escribir en cada bloque de ambos.</li>
</ul>
</li>
<li>
<p><strong>RAID 2 y 3</strong></p>
<ul>
<li>La idea es guardar por bloque info suficiente para determinar si se da√±√≥ o no, y a veces puedo corregir errores con esa info.</li>
<li>sigo distribuyendo los bloques entre todos los discos participantes</li>
<li>nro. discos
<ul>
<li>RAID 2: 3 de paridad por cada 4 de datos</li>
<li>RAID 3: 1 disco de paridad por cada 4 de datos</li>
</ul>
</li>
<li>todos los discos participan de todo I/O, por lo que es m√°s lento que incluso RAID 1</li>
<li>Requiere mucho c√≥mputo recalcular redundancias</li>
<li>si se implementa es por HW</li>
</ul>
</li>
<li>
<p><strong>RAID 4</strong></p>
<ul>
<li>como RAID 3 pero usa stripping por bloque (cada bloque va a un √∫nico disco)</li>
<li>el bottleneck sigue siendo el disco dedicado a paridad porque todo write tiene que tocarlo</li>
</ul>
</li>
<li>
<p><strong>RAID 5</strong></p>
</li>
</ul>
<p><img src="./img/raid_5.png#halfcenter" alt="" /></p>
<ul>
<li>
<ul>
<li>Usa datos redundantes pero los distribuye en N + 1 discos (cada write consecutivo va a discos distintos)</li>
<li>para cada bloque, un disco tiene la data y otro tiene info de paridad (hay info de paridad en todos los discos)</li>
<li>ya no tengo cuello de botella para los writes, pero mantener la paridad no es f√°cil</li>
<li>cae el rendimiento en la reconstrucci√≥n de info</li>
</ul>
</li>
<li>
<p><strong>RAID 6</strong></p>
</li>
</ul>
<p><img src="./img/raid_6.png#halfcenter" alt="" /></p>
<ul>
<li>
<ul>
<li>como RAID 5 pero agrega un segundo bloque de paridad tambi√©n distribuido, puede soportar la rotura de hasta 2 discos</li>
<li>No hay diferencia sustancial vs RAID 5 respecto del espacio desperdiciado (en la pr√°ctica se suele usar RAID 5 + hot spare)</li>
</ul>
</li>
</ul>
<h2 id="miscelaneos"><a class="header" href="#miscelaneos">Miscelaneos</a></h2>
<h3 id="ram-como-dispositivo"><a class="header" href="#ram-como-dispositivo">RAM como dispositivo</a></h3>
<p>Es posible crear <strong>RAM Drives</strong>, que consisten en separar una porci√≥n de la
DRAM del sistema y presentarlo al resto del sistema como si fuera otro
dispositivo de almacenamiento. Por qu√© tendr√≠a sentido hacer esto? Si bien el
SO usa caches y buffers para por ejemplo optimizar operaciones de I/O, esto le
permite <strong>al usuario</strong> guardar data en la memoria usando operaciones con
archivos. Si bien los dispositivos NVM (ej: SSD) son r√°pidos, la ram sigue
siendo mucho m√°s r√°pido.</p>
<h3 id="flujo-de-un-pedido-de-lecturaescritura-a-disco"><a class="header" href="#flujo-de-un-pedido-de-lecturaescritura-a-disco">Flujo de un pedido de lectura/escritura a disco</a></h3>
<ol>
<li>Cuando un proceso necesita <strong>I/O</strong> llama a una syscall del sistema
operativo. La syscall tiene varios par√°metros:</li>
</ol>
<ul>
<li>tipo de operaci√≥n (Input o Output)</li>
<li>el file descriptor indicando el archivo sobre el que se opera</li>
<li>la direcci√≥n de memoria de donde transferir</li>
<li>la cantidad de data a transferir</li>
</ul>
<ol start="2">
<li>Si el disco y su controlador est√°n disponibles, el pedido se atiende
inmediatamente. Si no, los pedidos se guardan en una cola de pendientes para
ese disco. Como vimos antes, el scheduler de I/O puede ordenar esa cola con
fines de mejorar la performance.</li>
</ol>
<div id="admonition-info" class="admonition info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="#admonition-info"></a></p>
</div>
<div>
<p>En el pasado, era necesario especificar el track y qu√© cabeza del HDD usar, y
los algoritmos de scheduling de disco eran m√°s complejos. Hoy en d√≠a mediante
el uso de LBAs (Logical Block Addresses) incluso el SO es abstraido de lo que
en realidad pasa en la memoria. Sin embargo, se sigue asumiendo que LBAs
cercanas significan accesos cercanos (f√≠sicamente hablando). Por lo tanto sigue
teniendo sentido tener consideraciones como:</p>
<ul>
<li>lecturas/escrituras en bloque</li>
<li>fairness</li>
<li>timeliness</li>
</ul>
</div>
</div>
<h3 id="el-deadline-scheduler-de-linux"><a class="header" href="#el-deadline-scheduler-de-linux">El <strong>deadline scheduler</strong> de linux</a></h3>
<p>Los algoritmos que vimos de scheduling de I/O tienen una desventaja muy grande,
y es que pueden producir inanici√≥n. Linux para resolver esto implement√≥ el
<strong>deadline scheduler</strong>. </p>
<p>Este scheduler mantiene 4 colas, dos de lectura y dos de escritura. La primera
cola es aquella ordenada por LBA (implementando en cierta forma un C-Scan), y
la segunda es una FIFO a la que se mandan todos aquellos pedidos que superan el
tiempo l√≠mite configurado (500ms por default).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="administracion_de_memoria.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="sistemas_de_archivos.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="administracion_de_memoria.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="sistemas_de_archivos.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
